import java.util.concurrent.ThreadLocalRandom

plugins {
    id "java"
}

sourceCompatibility = 1.8
targetCompatibility = 1.8

sourceSets {
    main {
        java.srcDirs = ["src"]
        java.outputDir = file("$buildDir/classes")
    }

    test {
        java.srcDirs = ["test"]
        java.outputDir = file("$buildDir/tests")
    }
}

configurations {
    client

    all {
        resolutionStrategy.cacheDynamicVersionsFor 60, "seconds"
    }
}

static def get(String url) {
    return new URL(url).text.trim() + "\n"
}

static def updateVariable(File file, String varName, Object newValue) {
    file.text = file.text.replaceFirst("($varName = ([^;]+);)", "$varName = $newValue;")
}

if (!project.hasProperty("classLocation")) {
    ext.classLocation = sourceSets.main.output.classesDirs.getAsPath()
}

def replayPath = "replays/${project.property("teamA")}-vs-${project.property("teamB")}-on-%MAP%.bc20"

def os = System.getProperty("os.name").toLowerCase()
def clientName = "battlecode-client-${os.startsWith("windows") ? "win" : os.startsWith("mac") ? "mac" : "linux"}"

def battlecodeVersion = file("version.txt").text.trim()
def battlecodeVersionUrl = "https://2020.battlecode.org/version.txt"

def examplefuncsplayerUrl = "https://raw.githubusercontent.com/battlecode/battlecode20-scaffold/master/src/examplefuncsplayer/RobotPlayer.java"
def examplefuncsplayerPath = "src/examplefuncsplayer/RobotPlayer.java"

def lectureplayerUrl = "https://raw.githubusercontent.com/battlecode/lectureplayer/master/RobotPlayer.java"
def lectureplayerPath = "src/lectureplayer/RobotPlayer.java"

repositories {
    maven {
        url "https://maven.pkg.github.com/battlecode/battlecode20"
        credentials {
            username = "battlecodedownloadpackage"
            password = get("https://2020.battlecode.org/access.txt").trim()
        }
    }
}

dependencies {
    implementation "org.battlecode:battlecode:$battlecodeVersion"
    implementation "org.battlecode:battlecode:$battlecodeVersion:javadoc"
    client "org.battlecode:$clientName:$battlecodeVersion"
}

task checkForUpdates {
    group "battlecode"
    description "Checks for Battlecode updates."

    doLast {
        def currentVersion = battlecodeVersion
        def latestVersion = get(battlecodeVersionUrl).trim()

        if (currentVersion != latestVersion) {
            print("\n\n\nBATTLECODE UPDATE AVAILABLE ($currentVersion -> $latestVersion)\n\n\n")
        }

        if (file(examplefuncsplayerPath).text != get(examplefuncsplayerUrl)) {
            print("\n\n\nEXAMPLEFUNCSPLAYER UPDATE AVAILABLE\n\n\n")
        }

        if (file(lectureplayerPath).text != get(lectureplayerUrl)) {
            print("\n\n\nLECTUREPLAYER UPDATE AVAILABLE\n\n\n")
        }
    }
}

task update {
    group "battlecode"
    description "Updates the Battlecode version and the default players."

    doLast {
        def currentVersion = battlecodeVersion
        def latestVersion = get(battlecodeVersionUrl).trim()

        if (currentVersion == latestVersion) {
            println("Already using the latest Battlecode version ($currentVersion)")
        } else {
            file("version.txt").text = latestVersion + "\n"
            println("Updated Battlecode from $currentVersion to $latestVersion, please reload the Gradle project")
        }

        file(examplefuncsplayerPath).text = get(examplefuncsplayerUrl)
        println("Updated examplefuncsplayer to latest version")

        file(lectureplayerPath).text = get(lectureplayerUrl)
        println("Updated lectureplayer to latest version")
    }
}

task unpackClient(type: Copy) {
    group "battlecode"
    description "Downloads the client."

    dependsOn configurations.client
    dependsOn checkForUpdates

    from {
        configurations.client.collect {
            zipTree(it)
        }
    }

    into "client/"
}

task run(type: JavaExec) {
    group "battlecode"
    description "Runs a match without starting the client."

    dependsOn "build"

    main = "battlecode.server.Main"
    classpath = sourceSets.main.runtimeClasspath
    args = ["-c=-"]
    jvmArgs = [
        "-Dbc.server.mode=headless",
        "-Dbc.server.map-path=maps",
        "-Dbc.server.debug=true",
        "-Dbc.engine.debug-methods=true",
        "-Dbc.game.team-a=${project.property("teamA")}",
        "-Dbc.game.team-b=${project.property("teamB")}",
        "-Dbc.game.team-a.url=${project.property("classLocation")}",
        "-Dbc.game.team-b.url=${project.property("classLocation")}",
        "-Dbc.game.maps=${project.property("maps")}",
        "-Dbc.server.save-file=${replayPath.replace("%MAP%", project.property("maps").toString())}"
    ]
}

task runFromClient(type: JavaExec) {
    group "battlecode"
    description "Runs a match in the client."

    dependsOn "build"

    main = "battlecode.server.Main"
    classpath = sourceSets.main.runtimeClasspath
    args = ["-c=-"]
    jvmArgs = [
        "-Dbc.server.wait-for-server=true",
        "-Dbc.server.mode=headless",
        "-Dbc.server.map-path=maps",
        "-Dbc.server.debug=false",
        "-Dbc.server.robot-player-to-system-out=false",
        "-Dbc.engine.debug-methods=true",
        "-Dbc.game.team-a=${project.property("teamA")}",
        "-Dbc.game.team-b=${project.property("teamB")}",
        "-Dbc.game.team-a.url=${project.property("classLocation")}",
        "-Dbc.game.team-b.url=${project.property("classLocation")}",
        "-Dbc.game.maps=${project.property("maps")}",
        "-Dbc.server.save-file=${replayPath.replace("%MAP%", project.property("maps").toString())}"
    ]
}

task runDebug(type: JavaExec) {
    group "battlecode"
    description "Runs a match in debug mode."

    dependsOn "build"

    main = "battlecode.server.Main"
    classpath = sourceSets.main.runtimeClasspath
    args = ["-c=-"]
    jvmArgs = [
        "-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5005",
        "-Dbc.server.mode=headless",
        "-Dbc.server.map-path=maps",
        "-Dbc.server.debug=false",
        "-Dbc.server.robot-player-to-system-out=true",
        "-Dbc.engine.debug-methods=true",
        "-Dbc.game.team-a=${project.property("teamA")}",
        "-Dbc.game.team-b=${project.property("teamB")}",
        "-Dbc.game.team-a.url=${project.property("classLocation")}",
        "-Dbc.game.team-b.url=${project.property("classLocation")}",
        "-Dbc.game.maps=${project.property("maps")}",
        "-Dbc.server.save-file=${replayPath.replace("%MAP%", project.property("maps").toString())}"
    ]
}

task listPlayers {
    group "battlecode"
    description "Lists all available players."

    doLast {
        def players = new ArrayList()

        sourceSets.main.allSource.each {
            if (it.name.equals("RobotPlayer.java")) {
                def base = file("src").toURI()
                def full = it.toURI()
                def path = base.relativize(full).toString()
                players.push(path.substring(0, path.lastIndexOf("/")).replaceAll("/", "."))
            }
        }

        players.sort(String.CASE_INSENSITIVE_ORDER)

        println("Players (${players.size()}):")
        for (def player : players) {
            println(player)
        }
    }
}

task listMaps {
    group "battlecode"
    description "Lists all available maps."

    doLast {
        def maps = new ArrayList()

        sourceSets.main.compileClasspath.each {
            if (it.toString().contains("battlecode-2020")) {
                def fileCollection = zipTree(it)
                fileCollection += fileTree(file("maps"))
                fileCollection.each {
                    if (it.name.endsWith(".map20")) {
                        maps.push(it.name.substring(0, it.name.indexOf(".map20")))
                    }
                }
            }
        }

        maps.sort(String.CASE_INSENSITIVE_ORDER)

        println("Maps (${maps.size()}):")
        for (def map : maps) {
            println(map)
        }
    }
}

task createSubmission(type: Zip) {
    group "battlecode"
    description "Creates a submission zip."

    dependsOn "build"

    from file("src/camel_case").getAbsolutePath()
    include "**/*"
    archiveName "${new Date().format("yyyy-MM-dd_kk-mm-ss")}.zip"
    destinationDir file("${project.buildDir}/submissions")
}

task generateData {
    group "battlecode"
    description "Write generated data to Java files."

    outputs.upToDateWhen { false }

    doLast {
        def file = file("src/camel_case/GeneratedData.java")

        def rnd = ThreadLocalRandom.current()

        for (int i = 1; i <= 3; i++) {
            int number = 0
            while (number == 0) {
                number = rnd.nextInt(-250, 251)
            }

            updateVariable(file, "MESSAGE_HASH_SECRET_$i", number)
        }
    }
}

build {
    group "battlecode"

    dependsOn "unpackClient"
    dependsOn "generateData"
}
